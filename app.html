<html>
<canvas id="canvas" width="400" height="400" style="border:1px solid #000000; background-color:rgb(0, 0, 204);"></canvas>
<img id="generatedImage" alt="Generated Image" />
<br>
<button id="facade">Facade</button>
<button id="door">Door</button>
<button id="shop">Shop</button>
<button id="molding">Molding</button>
<br>

<button id="balcony">Balcony</button>
<button id="pillar">Pillar</button>

<button id="window">Window</button>
<button id="cornice">Cornice</button>
<button id="sill">Sill</button>

<br>
<button id="resetButton">Reset</button>
<button id="saveButton">Save</button>
<button id="clearButton">Clear</button>
<button id="generateButton">Generate Image</button>



<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>

<script>
    let model;
    async function loadModel() {
        console.log('Loading Model ...');
        const MODEL_URL = 'https://seddik-turki.github.io/Sketch2Image/tfjs_gen_model/model.json';
        const model = await tf.loadLayersModel(MODEL_URL);
        console.log(model);
        console.log('model loaded!!');
        console.log(model.summary());
    }
    loadModel();
</script>

<script>
  function preprocessImage(canvas) {
      // Get image data from the canvas
      let img = tf.browser.fromPixels(canvas);

      // Resize to the required size (256x256)
      img = tf.image.resizeBilinear(img, [256, 256]);

      // Normalize the image
      img = img.toFloat().div(127.5).sub(1.0);

      // Add a batch dimension
      img = img.expandDims(0);

      return img;
  }
</script>

<script>
async function generateImage() {
  const canvas = document.getElementById('canvas');
  const preprocessedImage = preprocessImage(canvas);

  // Generate the image using the loaded model
  const generatedImage = model.predict(preprocessedImage);

  // Post-process the output (remove the batch dimension, de-normalize)
  let output = generatedImage.squeeze();
  output = output.add(1.0).mul(127.5);
  concole.log(output)

  // Create an offscreen canvas to render the image
  const offscreenCanvas = document.createElement('canvas');
  offscreenCanvas.width = 256; // Assuming the image size is 256x256
  offscreenCanvas.height = 256;
  await tf.browser.toPixels(output, offscreenCanvas);

  // Convert canvas to data URL and set it as the source of the <img> element
  const dataURL = offscreenCanvas.toDataURL();
  document.getElementById('generatedImage').src = dataURL;

  console.log('Image generated and displayed in img element.');
}

</script>

<script>
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var currentTool = NaN;
var isDrawing = false;
var startX, startY;
var currentRect = {};
var linestep = 50

// Function to draw guide lines
function drawGuidelines(step) {
  
ctx.setLineDash([5, 10]); // Set dash pattern
  for (var x = step; x < canvas.width; x += step) {
    if (x == canvas.width /2){
        ctx.strokeStyle = 'red';
        ctx.setLineDash([0]); // Set dash pattern
    }
    else{
        ctx.strokeStyle = 'white';
        ctx.setLineDash([5, 10]);
    }
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }

  for (var y = step; y < canvas.height; y += step) {
    if (y == canvas.height /2){
        ctx.strokeStyle = 'red';
        ctx.setLineDash([0]); // Set dash pattern
    }
    else{
        ctx.strokeStyle = 'white';
        ctx.setLineDash([5, 10]);
    }
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  ctx.setLineDash([]); // Reset to solid line for future drawings
}
class_colors={
        "background": "rgb(0,0,222)",
        "facade": "rgb(0,48,255)",
        "window": "rgb(0,128,253)",
        "molding": "rgb(255,80,0)",
        "door": "rgb(0,209,255)",
        "pillar": "rgb(252,0,0)",
        "shop": "rgb(175,0,0)",
        "deco": "rgb(175,0,0)",
        "cornice": "rgb(35,255,227)", // above the window
        "sill": "rgb(114,255,153)", // Under the window
        "balcony": "rgb(192,255,63)"
    }

document.getElementById('generateButton').onclick = generateImage;
// Button to choose drawing tool
document.getElementById('door').onclick = function() {toolcolor=class_colors['door'];currentTool=true;}
document.getElementById('window').onclick = function() { toolcolor=class_colors['window'];currentTool=true}
document.getElementById('balcony').onclick = function() { toolcolor=class_colors['balcony'];currentTool=true}
document.getElementById('facade').onclick = function() { toolcolor=class_colors['facade'];currentTool=true}
document.getElementById('molding').onclick = function() {toolcolor=class_colors['molding'];currentTool=true;}
document.getElementById('shop').onclick = function() {toolcolor=class_colors['shop'];currentTool=true;}
document.getElementById('pillar').onclick = function() {toolcolor=class_colors['pillar'];currentTool=true;}
document.getElementById('cornice').onclick = function() {toolcolor=class_colors['cornice'];currentTool=true;}
document.getElementById('sill').onclick = function() {toolcolor=class_colors['sill'];currentTool=true;}

document.getElementById('clearButton').onclick = function() {
    canvas.addEventListener('click', function(e) {
        var rect = canvas.getBoundingClientRect();
        var mouseX = e.clientX - rect.left;
        var mouseY = e.clientY - rect.top;
        
        // Check if the click is inside any of the drawn shapes
        shapes = shapes.filter(function(shape) {
            if (mouseX > shape.x && mouseX < shape.x + shape.width &&
                mouseY > shape.y && mouseY < shape.y + shape.height) {
                return false; // Remove this shape
            }
            return true; // Keep this shape
        });

        // Redraw canvas after removing the shape
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGuidelines(linestep);
        drawShapes();
    }, { once: true }); // Listen only for one click
};

document.getElementById('saveButton').onclick = function() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw the background color first
  ctx.fillStyle = "rgb(0, 0, 204)";  // The blue background color
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Redraw all the shapes
  drawShapes();

  // Save the image
  var dataURL = canvas.toDataURL('image/png');
  var link = document.createElement('a');
  link.href = dataURL;
  link.download = 'canvas_image.png';
  link.click();

  // Redraw the guidelines after saving
  drawGuidelines(linestep);
};
// Mouse down event to start drawing
canvas.addEventListener('mousedown', function(e) {
  if (currentTool) {
    isDrawing = true;
    var rect = canvas.getBoundingClientRect();
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;
  }
});



// Mouse move event to draw rectangle dynamically
canvas.addEventListener('mousemove', function(e) {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

    // Draw vertical and horizontal lines following the cursor
    drawGuidelines(linestep); // Draw guidelines every linestep
    ctx.beginPath();
    ctx.moveTo(e.offsetX, 0);
    ctx.lineTo(e.offsetX, canvas.height);
    ctx.moveTo(0, e.offsetY);
    ctx.lineTo(canvas.width, e.offsetY);
    ctx.strokeStyle = 'white';
    ctx.stroke();
    // Display coordinates with bigger font
    var coordinates = 'X: ' + e.offsetX + ', Y: ' + e.offsetY;
    ctx.fillStyle = 'white';
    ctx.font = 'bold 12px Arial';
    ctx.fillText(coordinates, e.offsetX + 10, e.offsetY - 10);

    drawShapes(); // Redraw all existing shapes
  if (isDrawing) {
    
    var rect = canvas.getBoundingClientRect();
    var currentX = e.clientX - rect.left;
    var currentY = e.clientY - rect.top;
    
    // Calculate the width and height based on mouse movement
    var width = currentX - startX;
    var height = currentY - startY;
    ctx.fillStyle = toolcolor
    // Draw the rectangle
    ctx.fillRect(startX, startY, width, height);
    
    // Save the current rectangle
    currentRect = {color: ctx.fillStyle, x: startX, y: startY, width: width, height: height};
  }
});

// Mouse up event to finalize the rectangle
canvas.addEventListener('mouseup', function(e) {
  if (isDrawing) {
    isDrawing = false;
    shapes.push(currentRect); // Save the drawn rectangle
  }
});

// Reset button to clear the canvas
document.getElementById('resetButton').onclick = function() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  shapes = [];  // Clear the shapes array
  drawGuidelines(linestep);
};

// To store the shapes drawn on the canvas
var shapes = [];

// Function to redraw shapes
function drawShapes() {
  shapes.forEach(function(shape) {
    ctx.fillStyle = shape.color;
    ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
  });
}
drawGuidelines(linestep);

</script>
</html>
